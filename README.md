/\*

This is Reactjs content Based on developing Chat App.

Lesson 1: Intro
    * ReactJs is a component based JavaScript UI library
        - It provides some built in utility which we can use across entire apps
        - It also makes the developemnt easy to mantaina and test since it is component based which allows decoupling
        - It also makes developmnt faster and productive due to its easy way of writting the UI codes compared to vanilla JavaScript.

        SPA : is An application that have only one html page and when we navigate through the apps, only the content of that page will change , the page will never change.

        If your app is server-rendered, using createRoot() is not supported. Use hydrateRoot() instead.

        When you want to render a piece of JSX in a different part of the DOM tree that isnâ€™t a child of your component (for example, a modal or a tooltip), use createPortal instead of createRoot.

        optional options: An object with options for this React root.

          optional onCaughtError: Callback called when React catches an error in an Error Boundary. Called with the error caught by the Error Boundary, and an errorInfo object containing the componentStack.

          optional onUncaughtError: Callback called when an error is thrown and not caught by an Error Boundary. Called with the error that was thrown, and an errorInfo object containing the componentStack.

          optional onRecoverableError: Callback called when React automatically recovers from errors. Called with an error React throws, and an errorInfo object containing the componentStack. Some recoverable errors may include the original error cause as error.cause.

          optional identifierPrefix: A string prefix React uses for IDs generated by useId. Useful to avoid conflicts when using multiple roots on the same page.

Lesson 2: Components
    * React Components are just a pice of UI code.
        - there are two types of components 
            class based components 
            functional based components 

        Props : properties of a component and used to share data between components , mainly from parent to child component.
            props.children is  special properties and will be evaluated to the value that is avilable in between the opening and closing tag of the component.

            key-props help react to identify a component specifically and also used for perforamce optimizing when we render lists. 


        EventBinding : we can create an event at the parent components and pass it to child component to be used for event binding annd update any data at the parent level that can be used in multiple child components.

        React Fragment : help us to avaoid rendering of uncessary html elements that we use as a wrapper to return multipl jsx elements.

        React Portal : help us to render a component out side of the root dom node hirarchy.
                    it is really helpful when we have deal with a parent css that renders model,popup or tool tip as its child component.

    class based components : It is a javascript class which extends component class from react and aslo it have render method that return the jsx that will be rendered on the dom.

        - state : to manage state we should initalize it within the constrcator of the class to an  object.
        NB: the name should be state( this.state = {})and to update the state we should use setState method on this within the class.

        class Demo extend Component{

            constracture(){
                super();
                this.state = {showBanner:true} // react will mange as state for us.
            }

            toggle(){
                this.setState({shiwBanner:false}) or this.setState((currentstate) =>{
                    return {showBanner:!currentstate.showBanner}
                })
                this
            }
        }
        
        - Life Cycle methods are special methods for class based component used to excute logics at certain stages of component life cycle.

          #componentDidMount() : similar with useEffect with no dependancy and it will be called once when the component mounted foir the first time
                    useEffect(() => {},[])
         # componentDidUpdate() : similar with use effect with dependancy but it will be excuted only when there is chsnge in state of the component.
                    useEffect(() => {},[state1])
         # componentWillUnmount : similar with the cleanUp() function of the use effect and it only be excuted just before the component is unmounted from the dom.

                useEffect(() = >{

                    clean()
                } ,[])

        - context in class based component are similar with the functional type of componentss in providing it but it  deffer in how it is consumed in class based components

            # we can consume using consumer utility on the context

                <Contex.consumer>
                {(ctx) =.{
                    retun jsx
                }}
                <Context.consumer>

            # we can also consume it using the static properties of the class called contextType and assign the context.

        - error boundry : class based component which implement componentDidCatch() method and used to hundle error thrown by children at the parent level.



Lesson 3 : React Hooks 

    * useState: used to register state for a specific component instance. for example if a component is rendered multiple times , each component instance will have its own state and react will manage it separtly. It also help us to have 2 way data binding along with the value attributes of the httm element and resetting the state using the useState returned method.
        NB: React always schedules state updates, due to this reason we have to always depend on the prev state and pass a function to the updating method the hook return. this will ensure that we get the updated snapshoot of the prev state.

    * useRef : It help us to have direct access to a DOM element with help of an inbuilt prop called 'ref' that we map it with our variable created with this hook.

    * useEffect :The useEffect Hook in React allows you to perform side effects in functional components. Side effects include data fetching, subscriptions, or manually changing the DOM [2, 3]. It is a powerful tool for managing logic that needs to run after the component renders
         useEefect

         useEffect(() => {
              // Code for the side effect
              return () => {
                        // Optional cleanup function
                  };
           }, [dependencies]); // Optional dependency array

       - If you omit the second argument (the dependency array), the effect runs after every single render of the component
       - If you provide an empty array [] as the second argument, the effect runs only once after the initial render
            - This is ideal for logic that only needs to happen when the component first mounts, such as fetching initial data from an API or setting up a subscription that lasts for the component's lifetime
       - If you include variables, props, or state within the dependency array, the effect runs after the initial render and whenever any of the values in the array change between renders 
            - This is the most common use case for synchronizing the component's state with external systems based on specific value changes (e.g., re-fetching data when a user ID changes, or updating the document title when a counter changes)

        The optional cleanup function helps you undo or stop whatever the side effect started. This is crucial for preventing memory leaks and unwanted behavior [3]. 
        The cleanup function runs before the effect runs again (if the dependencies have changed) and also before the component unmounts [3]. 
        How it works: You return a function from within your main useEffect callback.
         Common uses:
            Clearing timeouts or intervals.
            Unsubscribing from data streams or event listeners [3].
            Closing connections.
            Example (Subscription/Unsubscription)

    * useReducer: this hook is pretty similar with useState per functionality which is hundling state within a component. But it differ with syntax

            let [state , dispatch] = useReducer(reducer,initial state)

            state :  represent current state
            dispatch : represent a state updating function
            reducer : a function that change the state
            NB: whenever we call the dispatch function with some parameter, it always takes the state at its current state. we also need to create the reducer function based on our logic.

    * useContext : It allow us to manage state global wise and make it accessable through out the apps.

    * useImperativeHandle : forwardRef and useImperativeHandle are used together to allow a parent component to imperatively access a child component's underlying DOM node or a custom set of methods. 

        - forwardRef : It allows a parent component to gain direct access to a DOM element or component instance inside a child component, which is especially useful for actions like managing focus, selection, or animations.
         You wrap the child component definition in React.forwardRef((props, ref) => { ... }). The ref is provided as the second argument, which you then attach to the desired DOM element (e.g., <input ref={ref} />). 

       - useImperativeHandle : Instead of exposing the entire DOM node and all its methods, useImperativeHandle allows you to define a specific, limited API that the parent component can interact with. This promotes a more controlled and predictable interaction model.
        It takes the forwarded ref (from forwardRef), a function that returns the object you want to expose, and an optional dependency array. 



Lesson 4 : React Vartual DOM 

    * React is responsible for :
        - managing the component data and state and also it re-evaluates a component whenever a state changes 
        - compare and checks the difference between the privious state and current state and pass the information to the React DOM
    NB: React is not responsible for rendering something in the browsers DOM. So ReactDom is responsible to compare the vartual DOM and real DOM and update the real DOM only on the node needs an update.

    * React.memo() : we will trade the benefit of re evaluation for performance cost of comparing the props. this method will prevent re evaluation of a component unless there is a change in the state of context of this exact component.
    NB: this method will not prevent re evaluation of a component incase the component is refering a props value which is reference type(like an object and function).

    * useCallback() : Allow us to store a fuction accross a component excution lifecycle. React will store the function in react internal memory and will memoize it for us. It will work to prevent the issues with React.memo().

     let someFunction = useCallback(function(){},[dependancy]) : this somefunction will be created once and stored in react internal memory and the memory address will never get changed unless the dependancy changes.

    * useMemo() : Allow us to store a refernce types of value accross a component excution lifecycle. React will store the value in react internal memory and will memoize it for us. It will work to prevent the issues with React.memo().

     let list = useMemo(() => { return [1,2,3,4]},[dependancy]) : this list refrence type value  will be created once and stored in react internal memory and the memory address will never get changed unless the dependancy changes.

*/

